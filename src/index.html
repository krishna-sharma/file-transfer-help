<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <style>
      .limit-width {
        margin: auto;
        max-width: 800px;
      }
      .spacer {
        margin-top: 10px;
      }
      .center {
        text-align: center;
      }
      .fix-size {
        width: 100px;
      }
      #files-to-download {
        position: relative;
      }
      .file {
        width: 100%;
      }
      .file tbody tr:hover {
        cursor: pointer;
        background: #dddddd;
      }
    </style>

    <title>File Transfer Help</title>
  </head>
  <body>
    <div class="limit-width center">
      <h3>File Transfer Help</h3>
    </div>

    <form autocomplete="off" class="limit-width spacer" id="files-upload-form" name="files-upload-form" novalidate>
      <fieldset form="files-upload-form">
        <legend>Send Files</legend>
        <div class="center">
          <input id="files-to-upload" multiple type="file" />
        </div>
      </fieldset>
      <fieldset form="files-upload-form" class="spacer">
        <legend>Receive Files</legend>
        <div id="files-to-download"></div>
      </fieldset>
      <fieldset form="files-upload-form" class="spacer">
        <legend>Transfers</legend>
        <div id="file-transfers"></div>
      </fieldset>
    </form>

    <script>
      const el = document.getElementById("files-to-download");
      const ws = new WebSocket(location.origin.replace(/^http/, "ws"));
      const transfersContainer = document.querySelector("#file-transfers");
      const transfers = [];

      const getSize = (sizeInBytes) => {
        if (sizeInBytes < 1024) return `${sizeInBytes} B`;
        else if (sizeInBytes < 1024 * 1024) return `${Math.round((sizeInBytes / 1024) * 10) / 10} KB`;
        else if (sizeInBytes < 1024 * 1024 * 1024) return `${Math.round((sizeInBytes / (1024 * 1024)) * 10) / 10} MB`;
        else return `${Math.round((sizeInBytes / (1024 * 1024 * 1024)) * 10) / 10} GB`;
      };

      const showFileList = (availableFiles) => {
        const tableRows = availableFiles.map((availableFile) => {
          let modifiedDate = new Date(availableFile.lastModified);
          modifiedDate = new Date(modifiedDate.getTime() - modifiedDate.getTimezoneOffset() * 60000);
          modifiedDate = modifiedDate.toISOString().replace("T", " ").slice(0, -5);
          return `
              <tr class="${availableFile.clientId} ${availableFile.fileId}">
                <td>${availableFile.name}</td>
                <td class="center">${getSize(availableFile.size)}</td>
                <td class="center">${modifiedDate}</td>
                <td class="center">${availableFile.mimeType}</td>
              </tr>
            `;
        });
        el.innerHTML = `
            <table class="file">
              <thead>
                <tr>
                  <th>Filename</th>
                  <th>Size</th>
                  <th>Last Modified</th>
                  <th>Type</th>
                </tr>
              </thead>
              <tbody>
                ${tableRows.join("")}
              </tbody>
            </table>
          `;
        // TODO: remove transfers that are no longer available
        const filesAvailable = document.querySelectorAll("#files-to-download > table > tbody > tr");
        filesAvailable.forEach((fileRow) => {
          fileRow.onclick = function (event) {
            const [clientId, fileId] = this.classList;
            ws.send(JSON.stringify({ action: "REQUEST", payload: { clientId, fileId } }));
          };
        });
      };

      const uploadContent = (fileObj, transferId) => {
        const reader = fileObj.stream().getReader();
        const readErrorhandler = (error) => console.log(error);
        const readHandler = ({ value, done }) => {
          if (value) {
            const len = value.byteLength;
            const increment = 1024 * 7;
            for (let i = 0; i < value.byteLength; i += increment) {
              ws.send(value.subarray(i, i + increment));
            }
          }

          if (!done) {
            reader.read().then(readHandler, readErrorhandler);
          } else {
            ws.send(JSON.stringify({ action: "END", payload: { transferId } }));
          }
        };

        reader.read().then(readHandler, readErrorhandler);
      };

      const pickAndUploadFile = ({ filename, transferId }) => {
        const filesToUpload = document.querySelector("#files-to-upload").files;
        for (let i = 0; i < filesToUpload.length; i++) {
          if (filesToUpload[i].name === filename) {
            transfers.push({ type: "SEND", transferId, name: filename });
            uploadContent(filesToUpload[i], transferId);
            break;
          }
        }
      };

      const uploadMeta = () => {
        ws.send(JSON.stringify({ action: "CLEAR", payload: null }));
        // TODO: remove transfers that are no longer available
        const filesToUpload = document.querySelector("#files-to-upload").files;
        for (let i = 0; i < filesToUpload.length; i++) {
          const currentFile = filesToUpload[i];
          const currentFileMeta = {
            action: "ADD",
            payload: {
              name: currentFile.name,
              size: currentFile.size,
              mimeType: currentFile.type,
              lastModified: currentFile.lastModified,
            },
          };
          ws.send(JSON.stringify(currentFileMeta));
        }
      };

      const receiveContent = (data) => {
        const receiveTransfer = transfers.filter((transfer) => transfer.type === "RECEIVE")[0];
        if (receiveTransfer) {
          if (!receiveTransfer.response) {
            receiveTransfer.response = new Response(
              new ReadableStream({
                start(controller) {
                  receiveTransfer.controller = controller;
                },
              })
            );
            receiveTransfer.progress = 0;
            receiveTransfer.dataChain = Promise.resolve(true);
          }

          receiveTransfer.dataChain = receiveTransfer.dataChain.then(() =>
            data.arrayBuffer().then((arrayBuffer) => {
              receiveTransfer.controller.enqueue(new Uint8Array(arrayBuffer));
              receiveTransfer.progress += data.size;
              return true;
            })
          );
        }
      };

      ws.onmessage = (event) => {
        if (typeof event.data === "string") {
          const parsedData = JSON.parse(event.data);
          if (parsedData.action === "LIST") {
            showFileList(parsedData.payload);
          } else if (parsedData.action === "REQUEST") {
            pickAndUploadFile(parsedData.payload);
          } else if (parsedData.action === "START") {
            transfers.push({ type: "RECEIVE", ...parsedData.payload });
          } else if (parsedData.action === "END") {
            const receiveTransfer = transfers.filter((transfer) => transfer.type === "RECEIVE")[0];
            if (receiveTransfer && receiveTransfer.controller) {
              receiveTransfer.dataChain.then(() => {
                receiveTransfer.controller.close();
                receiveTransfer.response.blob().then((binaryData) => {
                  const blobUrl = window.URL.createObjectURL(binaryData);
                  const link = document.createElement("a");
                  link.href = blobUrl;
                  link.setAttribute("download", receiveTransfer.name);
                  document.body.appendChild(link);
                  link.click();
                  link.parentNode.removeChild(link);
                  window.URL.revokeObjectURL(blobUrl);
                });
                // TODO: cleanup receiveTransfer
              });
            }
          }
        } else {
          receiveContent(event.data);
        }
      };

      setInterval(() => {
        transfersContainer.innerHTML = transfers
          .map((transfer) => {
            const transferDetails = {
              type: transfer.type,
              transferId: transfer.transferId,
              name: transfer.name,
            };
            return `<pre>${JSON.stringify(transferDetails, null, 2)}<pre>`;
          })
          .join("");
      }, 1000);

      document.querySelector("#files-to-upload").addEventListener("change", uploadMeta);
    </script>
  </body>
</html>
